// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Belt_Option from "@rescript/runtime/lib/es6/Belt_Option.js";
import * as Belt_SetInt from "@rescript/runtime/lib/es6/Belt_SetInt.js";
import * as Belt_SetString from "@rescript/runtime/lib/es6/Belt_SetString.js";
import * as Stdlib_Promise from "@rescript/runtime/lib/es6/Stdlib_Promise.js";
import * as JsxRuntime from "react/jsx-runtime";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";

function divisionKey(prefix, division) {
  let slug = division.href !== "" ? division.href : division.title;
  return prefix + "/division/" + slug;
}

function sectionKey(prefix, section) {
  return prefix + "/section/" + section.title + "#" + section.level.toString();
}

function itemKey(prefix, link) {
  let slug = link.href !== "" ? link.href : link.title;
  return prefix + "/item/" + slug;
}

function collectSectionKeys(sections, prefix, acc) {
  return Belt_Array.reduce(sections, acc, (acc, section) => {
    let key = sectionKey(prefix, section);
    let nextAcc = Belt_SetString.add(acc, key);
    return collectSectionKeys(section.children, key, nextAcc);
  });
}

function collectItemKeys(items, prefix, acc) {
  return Belt_Array.reduce(items, acc, (acc, item) => {
    let key = itemKey(prefix, item);
    let nextAcc = Belt_SetString.add(acc, key);
    return collectItemKeys(item.children, key, nextAcc);
  });
}

function collectAllItemKeys(sections, prefix, acc) {
  return Belt_Array.reduce(sections, acc, (acc, section) => {
    let key = sectionKey(prefix, section);
    let nextAcc = collectItemKeys(section.items, key, acc);
    return collectAllItemKeys(section.children, key, nextAcc);
  });
}

function collectDivisionKeys(divisions, prefix, acc) {
  return Belt_Array.reduce(divisions, acc, (acc, division) => {
    let key = divisionKey(prefix, division);
    let nextAcc = Belt_SetString.add(acc, key);
    let nextSections = collectSectionKeys(division.sections, key, nextAcc);
    return collectDivisionKeys(division.children, key, nextSections);
  });
}

function collectDivisionItemKeys(divisions, prefix, acc) {
  return Belt_Array.reduce(divisions, acc, (acc, division) => {
    let key = divisionKey(prefix, division);
    let nextAcc = collectAllItemKeys(division.sections, key, acc);
    return collectDivisionItemKeys(division.children, key, nextAcc);
  });
}

function findSectionByKeyInSections(sections, targetKey, prefix) {
  return Belt_Array.reduce(sections, undefined, (acc, section) => {
    if (acc !== undefined) {
      return acc;
    }
    let key = sectionKey(prefix, section);
    if (key === targetKey) {
      return [
        section,
        prefix
      ];
    } else {
      return findSectionByKeyInSections(section.children, targetKey, key);
    }
  });
}

function findSectionByKey(divisions, targetKey, prefix) {
  return Belt_Array.reduce(divisions, undefined, (acc, division) => {
    if (acc !== undefined) {
      return acc;
    }
    let key = divisionKey(prefix, division);
    let result = findSectionByKeyInSections(division.sections, targetKey, key);
    if (result !== undefined) {
      return result;
    } else {
      return findSectionByKey(division.children, targetKey, key);
    }
  });
}

function findDivisionByKey(divisions, targetKey, prefix) {
  return Belt_Array.reduce(divisions, undefined, (acc, division) => {
    if (acc !== undefined) {
      return acc;
    }
    let key = divisionKey(prefix, division);
    if (key === targetKey) {
      return [
        division,
        prefix
      ];
    } else {
      return findDivisionByKey(division.children, targetKey, key);
    }
  });
}

function findDivisionPathByKey(divisions, targetKey, prefix) {
  return Belt_Array.reduce(divisions, undefined, (acc, division) => {
    if (acc !== undefined) {
      return acc;
    }
    let key = divisionKey(prefix, division);
    if (key === targetKey) {
      return [{
          title: division.title,
          key: key,
          kind: "division"
        }];
    }
    let path = findDivisionPathByKey(division.children, targetKey, key);
    if (path !== undefined) {
      return Belt_Array.concatMany([
        [{
            title: division.title,
            key: key,
            kind: "division"
          }],
        path
      ]);
    }
  });
}

function findSectionPathInSections(sections, targetKey, prefix) {
  return Belt_Array.reduce(sections, undefined, (acc, section) => {
    if (acc !== undefined) {
      return acc;
    }
    let key = sectionKey(prefix, section);
    if (key === targetKey) {
      return [{
          title: section.title,
          key: key,
          kind: "section"
        }];
    }
    let path = findSectionPathInSections(section.children, targetKey, key);
    if (path !== undefined) {
      return Belt_Array.concatMany([
        [{
            title: section.title,
            key: key,
            kind: "section"
          }],
        path
      ]);
    }
  });
}

function findSectionPathByKey(divisions, targetKey, prefix) {
  return Belt_Array.reduce(divisions, undefined, (acc, division) => {
    if (acc !== undefined) {
      return acc;
    }
    let key = divisionKey(prefix, division);
    let path = findSectionPathInSections(division.sections, targetKey, key);
    if (path !== undefined) {
      return Belt_Array.concatMany([
        [{
            title: division.title,
            key: key,
            kind: "division"
          }],
        path
      ]);
    }
    let path$1 = findSectionPathByKey(division.children, targetKey, key);
    if (path$1 !== undefined) {
      return Belt_Array.concatMany([
        [{
            title: division.title,
            key: key,
            kind: "division"
          }],
        path$1
      ]);
    }
  });
}

function App$ListView(props) {
  let setFocusedSectionKey = props.setFocusedSectionKey;
  let setFocusedDivisionKey = props.setFocusedDivisionKey;
  let setExpandedItems = props.setExpandedItems;
  let setExpanded = props.setExpanded;
  let focusedSectionKey = props.focusedSectionKey;
  let focusedDivisionKey = props.focusedDivisionKey;
  let showHeaders = props.showHeaders;
  let selectedLevels = props.selectedLevels;
  let expandedItems = props.expandedItems;
  let expanded = props.expanded;
  let includeChildrenOnMatch = props.includeChildrenOnMatch;
  let debouncedFilterText = props.debouncedFilterText;
  let divisions = props.divisions;
  let error = props.error;
  let levelMatchesSelection = (selectedLevels, levelOpt) => {
    if (levelOpt !== undefined) {
      return Belt_SetInt.has(selectedLevels, levelOpt);
    } else {
      return false;
    }
  };
  let query = debouncedFilterText.toLowerCase();
  let isAllLevelsSelected = Belt_SetInt.size(selectedLevels) === 5;
  let itemMatches = item => {
    if (levelMatchesSelection(selectedLevels, item.level)) {
      return item.title.toLowerCase().includes(query);
    } else {
      return false;
    }
  };
  let itemHasMatch = item => {
    if (itemMatches(item)) {
      return true;
    } else {
      return Belt_Array.some(item.children, itemHasMatch);
    }
  };
  let sectionMatches = section => section.title.toLowerCase().includes(query);
  let sectionHasMatch = section => {
    if (sectionMatches(section) || Belt_Array.some(section.items, itemHasMatch)) {
      return true;
    } else {
      return Belt_Array.some(section.children, sectionHasMatch);
    }
  };
  let divisionMatches = division => division.title.toLowerCase().includes(query);
  let divisionHasMatch = division => {
    if (divisionMatches(division) || Belt_Array.some(division.sections, sectionHasMatch)) {
      return true;
    } else {
      return Belt_Array.some(division.children, divisionHasMatch);
    }
  };
  let renderLink = (link, keyPrefix) => {
    let hasHref = link.href !== "";
    let href = "https://en.wikipedia.org" + link.href;
    let key = itemKey(keyPrefix, link);
    let isOpen = Belt_SetString.has(expandedItems, key) || includeChildrenOnMatch && query !== "" && itemHasMatch(link);
    let level = link.level;
    return JsxRuntime.jsxs("li", {
      children: [
        JsxRuntime.jsxs("div", {
          children: [
            JsxRuntime.jsxs("span", {
              children: [
                hasHref ? JsxRuntime.jsx("a", {
                    children: link.title,
                    className: "text-sky-700 hover:text-sky-900 underline decoration-sky-300",
                    href: href,
                    rel: "noreferrer",
                    target: "_blank"
                  }) : JsxRuntime.jsx("span", {
                    children: link.title,
                    className: "text-stone-700"
                  }),
                level !== undefined && level !== 5 ? JsxRuntime.jsx("span", {
                    children: level.toString(),
                    className: "ml-1"
                  }) : null
              ]
            }),
            link.children.length !== 0 ? JsxRuntime.jsx("button", {
                children: isOpen ? "−" : "+",
                className: "rounded border-stone-200 px-2 py-1 text-[10px] font-semibold text-stone-600 hover:border-stone-300",
                onClick: param => setExpandedItems(prev => {
                  if (Belt_SetString.has(prev, key)) {
                    return Belt_SetString.remove(prev, key);
                  } else {
                    return Belt_SetString.add(prev, key);
                  }
                })
              }) : null
          ],
          className: "flex items-center gap-2"
        }),
        link.children.length !== 0 && isOpen ? JsxRuntime.jsx("ul", {
            children: Belt_Array.map(link.children, child => renderLink(child, key)),
            className: "ml-5 list-disc text-sm text-stone-600"
          }) : null
      ],
      className: "my-1"
    }, key);
  };
  let filterSection = section => {
    let titleMatch = sectionMatches(section);
    let filterItem = item => {
      let levelMatch = levelMatchesSelection(selectedLevels, item.level);
      let itemMatch = item.title.toLowerCase().includes(query);
      let children = includeChildrenOnMatch && query !== "" && itemMatch ? item.children : Belt_Array.keepMap(item.children, filterItem);
      if (levelMatch && (query === "" || itemMatch) || children.length !== 0) {
        return {
          title: item.title,
          href: item.href,
          level: item.level,
          children: children
        };
      }
    };
    let items = includeChildrenOnMatch && query !== "" && titleMatch ? section.items : Belt_Array.keepMap(section.items, filterItem);
    let children = includeChildrenOnMatch && query !== "" && titleMatch ? section.children : Belt_Array.keepMap(section.children, filterSection);
    if (query === "") {
      if (items.length !== 0 || children.length !== 0) {
        return {
          title: section.title,
          level: section.level,
          items: items,
          children: children
        };
      } else {
        return;
      }
    } else if (titleMatch || items.length !== 0 || children.length !== 0) {
      return {
        title: section.title,
        level: section.level,
        items: items,
        children: children
      };
    } else {
      return;
    }
  };
  let filterDivision = division => {
    let titleMatch = divisionMatches(division);
    let sections = includeChildrenOnMatch && query !== "" && titleMatch ? division.sections : Belt_Array.keepMap(division.sections, filterSection);
    let children = includeChildrenOnMatch && query !== "" && titleMatch ? division.children : Belt_Array.keepMap(division.children, filterDivision);
    if (query === "") {
      if (sections.length !== 0 || children.length !== 0) {
        return {
          title: division.title,
          href: division.href,
          sections: sections,
          children: children
        };
      } else {
        return;
      }
    } else if (titleMatch || sections.length !== 0 || children.length !== 0) {
      return {
        title: division.title,
        href: division.href,
        sections: sections,
        children: children
      };
    } else {
      return;
    }
  };
  React.useEffect(() => {
    if (debouncedFilterText !== "" && divisions !== undefined) {
      let visibleDivisions = query === "" && isAllLevelsSelected ? divisions : Belt_Array.keepMap(divisions, filterDivision);
      setExpanded(param => collectDivisionKeys(visibleDivisions, "root", undefined));
      setExpandedItems(param => collectDivisionItemKeys(visibleDivisions, "root", undefined));
    }
  }, [
    debouncedFilterText,
    divisions,
    selectedLevels,
    includeChildrenOnMatch
  ]);
  let toggleExpanded = key => setExpanded(prev => {
    if (Belt_SetString.has(prev, key)) {
      return Belt_SetString.remove(prev, key);
    } else {
      return Belt_SetString.add(prev, key);
    }
  });
  let renderSection = (section, keyPrefix, depth) => {
    let key = sectionKey(keyPrefix, section);
    let isOpen = Belt_SetString.has(expanded, key) || includeChildrenOnMatch && query !== "" && sectionHasMatch(section);
    if (showHeaders) {
      return JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx("button", {
                children: section.title,
                className: "text-left text-sm font-semibold text-stone-800 hover:text-sky-700",
                onClick: param => {
                  setFocusedSectionKey(param => key);
                  setFocusedDivisionKey(param => {});
                }
              }),
              JsxRuntime.jsx("button", {
                children: isOpen ? "−" : "+",
                className: "rounded border-stone-200 px-2 py-1 text-xs font-semibold text-stone-600 hover:border-stone-300",
                onClick: param => toggleExpanded(key)
              })
            ],
            className: "flex items-center gap-2 font-semibold text-stone-800"
          }),
          isOpen ? JsxRuntime.jsxs("div", {
              children: [
                section.items.length !== 0 ? JsxRuntime.jsx("ul", {
                    children: Belt_Array.map(section.items, item => renderLink(item, key)),
                    className: "ml-8 list-disc text-sm text-stone-700"
                  }) : null,
                section.children.length !== 0 ? JsxRuntime.jsx("div", {
                    children: Belt_Array.map(section.children, child => renderSection(child, key, depth + 1 | 0)),
                    className: " border-stone-200"
                  }) : null
              ]
            }) : null
        ],
        className: depth === 0 ? "" : "ml-4"
      }, key);
    } else {
      return JsxRuntime.jsxs("div", {
        children: [
          section.items.length !== 0 ? JsxRuntime.jsx("ul", {
              children: Belt_Array.map(section.items, item => renderLink(item, key)),
              className: "ml-4 list-disc text-sm text-stone-700"
            }) : null,
          section.children.length !== 0 ? JsxRuntime.jsx("div", {
              children: Belt_Array.map(section.children, child => renderSection(child, key, depth + 1 | 0)),
              className: " border-stone-200"
            }) : null
        ]
      }, key);
    }
  };
  let renderDivision = (division, keyPrefix, depth) => {
    let key = divisionKey(keyPrefix, division);
    let isOpen = Belt_SetString.has(expanded, key) || includeChildrenOnMatch && query !== "" && divisionHasMatch(division);
    if (showHeaders) {
      return JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsx("button", {
                children: division.title,
                className: "text-left text-sm font-semibold text-stone-900 hover:text-sky-700",
                onClick: param => {
                  setFocusedDivisionKey(param => key);
                  setFocusedSectionKey(param => {});
                }
              }),
              JsxRuntime.jsx("button", {
                children: isOpen ? "−" : "+",
                className: "rounded border-stone-200 px-2 py-1 text-xs font-semibold text-stone-600 hover:border-stone-300",
                onClick: param => toggleExpanded(key)
              })
            ],
            className: "flex items-center gap-2 font-semibold text-stone-900"
          }),
          isOpen ? JsxRuntime.jsxs("div", {
              children: [
                division.sections.length !== 0 ? JsxRuntime.jsx("ul", {
                    children: Belt_Array.map(division.sections, section => renderSection(section, key, 0)),
                    className: "ml-2 list-disc text-sm text-stone-700"
                  }) : null,
                division.children.length !== 0 ? JsxRuntime.jsx("div", {
                    children: Belt_Array.map(division.children, child => renderDivision(child, key, depth + 1 | 0)),
                    className: "border-stone-200"
                  }) : null
              ]
            }) : null
        ],
        className: depth === 0 ? "" : "ml-4"
      }, key);
    } else {
      return JsxRuntime.jsxs("div", {
        children: [
          division.sections.length !== 0 ? JsxRuntime.jsx("ul", {
              children: Belt_Array.map(division.sections, section => renderSection(section, key, 0)),
              className: "ml-4 list-disc text-sm text-stone-700"
            }) : null,
          division.children.length !== 0 ? JsxRuntime.jsx("div", {
              children: Belt_Array.map(division.children, child => renderDivision(child, key, depth + 1 | 0)),
              className: "border-stone-200"
            }) : null
        ]
      }, key);
    }
  };
  let renderFocusedDivision = (division, keyPrefix) => {
    let key = divisionKey(keyPrefix, division);
    return JsxRuntime.jsxs("div", {
      children: [
        division.sections.length !== 0 ? JsxRuntime.jsx("ul", {
            children: Belt_Array.map(division.sections, section => renderSection(section, key, 0)),
            className: "list-disc text-sm text-stone-700"
          }) : null,
        division.children.length !== 0 ? JsxRuntime.jsx("div", {
            children: Belt_Array.map(division.children, child => renderDivision(child, key, 0)),
            className: "border-stone-200"
          }) : null
      ]
    });
  };
  let renderBreadcrumb = crumbs => {
    let crumbCount = crumbs.length;
    return JsxRuntime.jsxs("div", {
      children: [
        JsxRuntime.jsx("button", {
          children: "All divisions",
          className: "text-left text-sm font-semibold text-stone-700 hover:text-sky-700",
          onClick: param => {
            setFocusedDivisionKey(param => {});
            setFocusedSectionKey(param => {});
          }
        }),
        Belt_Array.mapWithIndex(crumbs, (index, crumb) => {
          let isLast = index === (crumbCount - 1 | 0);
          return JsxRuntime.jsxs(JsxRuntime.Fragment, {
            children: [
              JsxRuntime.jsx("span", {
                children: "›",
                className: "text-stone-400"
              }),
              JsxRuntime.jsx("button", {
                children: crumb.title,
                className: "text-left text-sm font-semibold " + (
                  isLast ? "text-stone-900" : "text-stone-700 hover:text-sky-700"
                ),
                onClick: param => {
                  let match = crumb.kind;
                  if (match === "section") {
                    setFocusedSectionKey(param => crumb.key);
                    return setFocusedDivisionKey(param => {});
                  }
                  setFocusedDivisionKey(param => crumb.key);
                  setFocusedSectionKey(param => {});
                }
              })
            ]
          });
        })
      ],
      className: "flex flex-wrap items-center gap-2 text-sm font-semibold text-stone-800"
    });
  };
  if (error !== undefined) {
    return JsxRuntime.jsx("div", {
      children: error,
      className: "rounded border border-red-200 bg-red-50 p-3 text-sm text-red-700"
    });
  }
  if (divisions === undefined) {
    return JsxRuntime.jsx("div", {
      children: "Loading divisions…",
      className: "text-sm text-stone-500"
    });
  }
  let visibleDivisions = query === "" && isAllLevelsSelected ? divisions : Belt_Array.keepMap(divisions, filterDivision);
  if (focusedDivisionKey !== undefined) {
    let match = findDivisionByKey(visibleDivisions, focusedDivisionKey, "root");
    if (match === undefined) {
      return JsxRuntime.jsx("div", {
        children: "That division is no longer available.",
        className: "rounded border-stone-100 bg-white p-4 text-sm text-stone-600"
      });
    }
    let division = match[0];
    let breadcrumb = Belt_Option.getWithDefault(findDivisionPathByKey(visibleDivisions, focusedDivisionKey, "root"), [{
        title: division.title,
        key: focusedDivisionKey,
        kind: "division"
      }]);
    return JsxRuntime.jsxs("div", {
      children: [
        JsxRuntime.jsx("div", {
          children: renderBreadcrumb(breadcrumb),
          className: "mb-4 flex items-center gap-3"
        }),
        renderFocusedDivision(division, match[1])
      ],
      className: "rounded border-stone-100 bg-white"
    });
  }
  if (focusedSectionKey === undefined) {
    return JsxRuntime.jsxs("div", {
      children: [
        JsxRuntime.jsx("div", {
          children: JsxRuntime.jsx("span", {
            children: "All divisions",
            className: "text-sm font-semibold text-stone-800"
          }),
          className: "mb-4 flex items-center gap-3"
        }),
        Belt_Array.map(visibleDivisions, division => renderDivision(division, "root", 0))
      ],
      className: "rounded border-stone-100 bg-white"
    });
  }
  let match$1 = findSectionByKey(visibleDivisions, focusedSectionKey, "root");
  if (match$1 === undefined) {
    return JsxRuntime.jsx("div", {
      children: "That section is no longer available.",
      className: "rounded border-stone-100 bg-white p-4 text-sm text-stone-600"
    });
  }
  let section = match$1[0];
  let breadcrumb$1 = Belt_Option.getWithDefault(findSectionPathByKey(visibleDivisions, focusedSectionKey, "root"), [{
      title: section.title,
      key: focusedSectionKey,
      kind: "section"
    }]);
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsx("div", {
        children: renderBreadcrumb(breadcrumb$1),
        className: "mb-4 flex items-center gap-3"
      }),
      renderSection(section, match$1[1], 0)
    ],
    className: "rounded border-stone-100 bg-white"
  });
}

let make = React.memo(App$ListView);

function App(props) {
  let match = React.useState(() => {});
  let setDivisions = match[1];
  let divisions = match[0];
  let match$1 = React.useState(() => {});
  let setError = match$1[1];
  let match$2 = React.useState(() => "");
  let setFilterText = match$2[1];
  let filterText = match$2[0];
  let match$3 = React.useState(() => "");
  let setDebouncedFilterText = match$3[1];
  let match$4 = React.useTransition();
  let startTransition = match$4[1];
  let isPending = match$4[0];
  let match$5 = React.useState(() => false);
  let setShowSlowFilterLabel = match$5[1];
  let match$6 = React.useState(() => true);
  let setIncludeChildrenOnMatch = match$6[1];
  let includeChildrenOnMatch = match$6[0];
  let match$7 = React.useState(() => {});
  let setExpanded = match$7[1];
  let match$8 = React.useState(() => {});
  let setExpandedItems = match$8[1];
  let match$9 = React.useState(() => Belt_SetInt.fromArray([
    1,
    2,
    3,
    4,
    5
  ]));
  let setSelectedLevels = match$9[1];
  let selectedLevels = match$9[0];
  let match$10 = React.useState(() => true);
  let setShowHeaders = match$10[1];
  let showHeaders = match$10[0];
  let match$11 = React.useState(() => {});
  let setFocusedDivisionKey = match$11[1];
  let focusedDivisionKey = match$11[0];
  let match$12 = React.useState(() => {});
  let setFocusedSectionKey = match$12[1];
  let focusedSectionKey = match$12[0];
  React.useEffect(() => {
    Stdlib_Promise.$$catch(fetch("/vitals-level5.json").then(response => {
      if (response.ok) {
        return response.json();
      } else {
        return Promise.reject(Primitive_exceptions.internalToException("Failed to load vitals-level5.json"));
      }
    }).then(payload => {
      let divisions = payload.divisions;
      setDivisions(param => divisions);
      setExpanded(param => {});
      setExpandedItems(param => {});
      setFocusedDivisionKey(param => {});
      setFocusedSectionKey(param => {});
      return Promise.resolve();
    }), param => {
      setError(param => "Failed to load the Vital Articles list.");
      return Promise.resolve();
    });
  }, []);
  React.useEffect(() => {
    if (filterText === "") {
      setDebouncedFilterText(param => "");
      return;
    }
    let timeoutId = setTimeout(() => startTransition(() => setDebouncedFilterText(param => filterText)), 500);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [filterText]);
  React.useEffect(() => {
    if (isPending) {
      let timeoutId = setTimeout(() => setShowSlowFilterLabel(param => true), 1000);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    setShowSlowFilterLabel(param => false);
  }, [isPending]);
  let expandAll = () => {
    if (divisions === undefined) {
      return;
    }
    if (focusedDivisionKey !== undefined) {
      let match = findDivisionByKey(divisions, focusedDivisionKey, "root");
      if (match === undefined) {
        return;
      }
      let prefix = match[1];
      let division = match[0];
      setExpanded(param => collectDivisionKeys([division], prefix, undefined));
      return setExpandedItems(param => collectDivisionItemKeys([division], prefix, undefined));
    }
    if (focusedSectionKey !== undefined) {
      let match$1 = findSectionByKey(divisions, focusedSectionKey, "root");
      if (match$1 === undefined) {
        return;
      }
      let prefix$1 = match$1[1];
      let section = match$1[0];
      setExpanded(param => collectSectionKeys([section], prefix$1, undefined));
      return setExpandedItems(param => collectAllItemKeys([section], prefix$1, undefined));
    }
    setExpanded(param => collectDivisionKeys(divisions, "root", undefined));
    setExpandedItems(param => collectDivisionItemKeys(divisions, "root", undefined));
  };
  let collapseAll = () => {
    if (divisions !== undefined) {
      if (focusedDivisionKey !== undefined) {
        let match = findDivisionByKey(divisions, focusedDivisionKey, "root");
        if (match === undefined) {
          return;
        }
        let prefix = match[1];
        let division = match[0];
        setExpanded(param => Belt_SetString.add(undefined, divisionKey(prefix, division)));
        return setExpandedItems(param => {});
      }
      if (focusedSectionKey !== undefined) {
        let match$1 = findSectionByKey(divisions, focusedSectionKey, "root");
        if (match$1 === undefined) {
          return;
        }
        let prefix$1 = match$1[1];
        let section = match$1[0];
        setExpanded(param => Belt_SetString.add(undefined, sectionKey(prefix$1, section)));
        return setExpandedItems(param => {});
      }
    }
    if (focusedDivisionKey !== undefined || focusedSectionKey !== undefined) {
      return;
    } else {
      setExpanded(param => {});
      return setExpandedItems(param => {});
    }
  };
  React.useEffect(() => {
    if (divisions !== undefined) {
      if (focusedDivisionKey !== undefined) {
        let match = findDivisionByKey(divisions, focusedDivisionKey, "root");
        if (match !== undefined) {
          let prefix = match[1];
          let division = match[0];
          setExpanded(param => collectDivisionKeys([division], prefix, undefined));
          setExpandedItems(param => collectDivisionItemKeys([division], prefix, undefined));
        }
      } else if (focusedSectionKey !== undefined) {
        let match$1 = findSectionByKey(divisions, focusedSectionKey, "root");
        if (match$1 !== undefined) {
          let prefix$1 = match$1[1];
          let section = match$1[0];
          setExpanded(param => collectSectionKeys([section], prefix$1, undefined));
          setExpandedItems(param => collectAllItemKeys([section], prefix$1, undefined));
        }
      } else {
        setExpanded(param => {
          let prefix = "root";
          let acc;
          return Belt_Array.reduce(divisions, acc, (acc, division) => {
            let key = divisionKey(prefix, division);
            return Belt_SetString.add(acc, key);
          });
        });
        setExpandedItems(param => {});
      }
    }
  }, [
    divisions,
    focusedDivisionKey,
    focusedSectionKey
  ]);
  return JsxRuntime.jsxs("div", {
    children: [
      JsxRuntime.jsxs("div", {
        children: [
          JsxRuntime.jsx("p", {
            children: "Wikipedia Vital Articles",
            className: "text-sm uppercase tracking-widest text-stone-500"
          }),
          JsxRuntime.jsxs("div", {
            children: [
              JsxRuntime.jsxs("div", {
                children: [
                  JsxRuntime.jsx("input", {
                    className: "w-full rounded-xl border border-stone-200 bg-white px-4 py-3 pr-10 text-sm text-stone-700 shadow-sm focus:border-sky-300 focus:outline-none",
                    placeholder: "Filter sections or articles",
                    value: filterText,
                    onChange: event => setFilterText(param => event.target.value)
                  }),
                  filterText !== "" ? JsxRuntime.jsx("button", {
                      children: "×",
                      "aria-label": "Clear search",
                      className: "absolute right-3 top-1/2 -translate-y-1/2 rounded-full p-1 text-stone-500 hover:text-stone-700",
                      type: "button",
                      onClick: param => setFilterText(param => "")
                    }) : null
                ],
                className: "relative w-full"
              }),
              match$5[0] ? JsxRuntime.jsx("span", {
                  children: "Loading…",
                  className: "text-xs font-semibold uppercase tracking-wider text-stone-500"
                }) : null,
              JsxRuntime.jsxs("div", {
                children: [
                  JsxRuntime.jsx("div", {
                    children: Belt_Array.map([
                      1,
                      2,
                      3,
                      4,
                      5
                    ], level => {
                      let isSelected = Belt_SetInt.has(selectedLevels, level);
                      return JsxRuntime.jsx("button", {
                        children: "Level " + level.toString(),
                        className: "first:rounded-l last:rounded-r border px-3 py-2 text-xs font-semibold uppercase tracking-wider " + (
                          isSelected ? "border-sky-300 bg-sky-50 text-sky-800" : "border-stone-200 bg-white text-stone-600 hover:border-stone-300"
                        ),
                        onClick: param => setSelectedLevels(prev => {
                          if (Belt_SetInt.has(prev, level)) {
                            return Belt_SetInt.remove(prev, level);
                          } else {
                            return Belt_SetInt.add(prev, level);
                          }
                        })
                      }, level.toString());
                    }),
                    className: "flex flex-wrap"
                  }),
                  JsxRuntime.jsxs("div", {
                    children: [
                      JsxRuntime.jsx("button", {
                        children: "Expand all",
                        className: "rounded-l border border-stone-200 bg-white px-3 py-2 text-xs font-semibold uppercase tracking-wider text-stone-600 hover:border-stone-300",
                        onClick: param => expandAll()
                      }),
                      JsxRuntime.jsx("button", {
                        children: "Collapse all",
                        className: "rounded-r border border-stone-200 bg-white px-3 py-2 text-xs font-semibold uppercase tracking-wider text-stone-600 hover:border-stone-300",
                        onClick: param => collapseAll()
                      })
                    ],
                    className: "flex flex-wrap"
                  }),
                  JsxRuntime.jsxs("label", {
                    children: [
                      JsxRuntime.jsx("input", {
                        className: "h-4 w-4 rounded border-stone-300 text-sky-600 focus:ring-sky-300",
                        checked: includeChildrenOnMatch,
                        type: "checkbox",
                        onChange: param => setIncludeChildrenOnMatch(prev => !prev)
                      }),
                      "incl. result desc."
                    ],
                    className: "w-fit flex items-center gap-2 text-xs font-semibold uppercase tracking-wider text-stone-600"
                  }),
                  JsxRuntime.jsxs("label", {
                    children: [
                      JsxRuntime.jsx("input", {
                        className: "h-4 w-4 rounded border-stone-300 text-sky-600 focus:ring-sky-300",
                        checked: !showHeaders,
                        type: "checkbox",
                        onChange: param => setShowHeaders(prev => !prev)
                      }),
                      "hide divisions"
                    ],
                    className: "w-fit flex items-center gap-2 text-xs font-semibold uppercase tracking-wider text-stone-600"
                  })
                ],
                className: "flex flex-wrap gap-2"
              })
            ],
            className: "mt-4 flex flex-col gap-3 md:flex-row md:items-center"
          })
        ],
        className: "mb-8"
      }),
      JsxRuntime.jsx(make, {
        error: match$1[0],
        divisions: divisions,
        debouncedFilterText: match$3[0],
        includeChildrenOnMatch: includeChildrenOnMatch,
        expanded: match$7[0],
        expandedItems: match$8[0],
        selectedLevels: selectedLevels,
        showHeaders: showHeaders,
        focusedDivisionKey: focusedDivisionKey,
        focusedSectionKey: focusedSectionKey,
        setExpanded: setExpanded,
        setExpandedItems: setExpandedItems,
        setFocusedDivisionKey: setFocusedDivisionKey,
        setFocusedSectionKey: setFocusedSectionKey
      })
    ],
    className: "mx-auto max-w-5xl p-6"
  });
}

let make$1 = App;

export {
  make$1 as make,
}
/* make Not a pure module */
